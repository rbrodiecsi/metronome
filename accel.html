<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Live Accel Plot (Plotly.js)</title>
  <style>
    body { font-family: sans-serif; padding: 1rem; background: #f0f0f0; }
    #controls { margin-bottom: 1rem; }
    #chart { width: 100%; max-width: 700px; height: 400px; margin: auto; }
    button { padding: 0.5rem 1rem; font-size: 1rem; }
  </style>
</head>
<body>
  <div id="controls">
    <button id="startBtn">Start Sensors & Plot</button>
  </div>
  <div id="chart"></div>

  <!-- Plotly.js -->
  <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
  <script>
    const MAX_WINDOW = 5000;    // ms of data to show
    const UPDATE_INTERVAL = 100; // ms between chart updates

    // Hold the latest sample
    let lastSample = { x: 0, y: 0, z: 0 };

    // Initialize empty traces
    const traces = [
      { x: [], y: [], name: 'X', mode: 'lines', line: { color: 'red' } },
      { x: [], y: [], name: 'Y', mode: 'lines', line: { color: 'green' } },
      { x: [], y: [], name: 'Z', mode: 'lines', line: { color: 'blue' } }
    ];

    // Create the Plotly plot
    Plotly.newPlot('chart', traces, {
      xaxis: {
        type: 'date',
        range: [ Date.now() - MAX_WINDOW, Date.now() ],
        title: 'Time'
      },
      yaxis: {
        title: 'Acceleration (m/sÂ²)'
      },
      margin: { t: 30 }
    });

    // Every UPDATE_INTERVAL, push the latest sample into each trace
    function updatePlot() {
      const now = new Date();
      Plotly.extendTraces('chart', {
        x: [[now], [now], [now]],
        y: [[lastSample.x], [lastSample.y], [lastSample.z]]
      }, [0, 1, 2]);

      // Slide the window
      Plotly.relayout('chart', {
        'xaxis.range': [ Date.now() - MAX_WINDOW, Date.now() ]
      });
    }

    // Try Generic Sensor API, else fallback
    function startSensors() {
      if ('Accelerometer' in window) {
        try {
          const sensor = new Accelerometer({ frequency: 60 });
          sensor.addEventListener('reading', () => {
            lastSample = { x: sensor.x, y: sensor.y, z: sensor.z };
          });
          sensor.addEventListener('error', e => {
            console.warn('Accelerometer error:', e.error);
            startFallback();
          });
          sensor.start();
          return;
        } catch (e) {
          console.warn('Accelerometer ctor failed:', e);
        }
      }
      startFallback();
    }

    // Fallback to devicemotion
    function startFallback() {
      if (!('DeviceMotionEvent' in window)) {
        alert('No accelerometer support!');
        return;
      }
      const listen = () => {
        window.addEventListener('devicemotion', ev => {
          const a = ev.accelerationIncludingGravity || ev.acceleration;
          if (!a) return;
          lastSample = { x: a.x, y: a.y, z: a.z };
        });
      };
      if (typeof DeviceMotionEvent.requestPermission === 'function') {
        DeviceMotionEvent.requestPermission()
          .then(p => p === 'granted' ? listen() : alert('Permission denied'))
          .catch(console.error);
      } else {
        listen();
      }
    }

    // Wire up the Start button
    document.getElementById('startBtn').addEventListener('click', () => {
      document.getElementById('startBtn').disabled = true;
      startSensors();
      setInterval(updatePlot, UPDATE_INTERVAL);
    });
  </script>
</body>
</html>
